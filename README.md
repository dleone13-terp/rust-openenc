# rust-openenc

S-57 Electronic Navigational Chart (ENC) ingestion pipeline. Reads S-57 files via GDAL, extracts feature layers, and upserts them into PostGIS with MVT tile serving support.


## Adding a New Feature Layer

To add a new S-57 feature layer (especially area-based layers, prioritized for Njord parity):

### 1. Create a Feature Module

- Add a new file in `src/features/` (e.g., `achare.rs`).
- Define a `LayerDef` constant for the feature, specifying:
  - `s57_name`: S-57 object name (e.g., "ACHARE")
  - `table`: Postgres table name (snake_case, e.g., "achare")
  - `columns`: List of `ColumnDef` for only the required S-57 attributes (as in Njord)
  - `style_fn`: Function for style token assignment, matching Njord's styling
  - `style_layers`: Array of `StyleLayerDef` for Mapbox GL style layers (e.g., fill, line, icon, text), matching Njord

Example:
```rust
pub const ACHARE: LayerDef = LayerDef {
  s57_name: "ACHARE",
  table: "achare",
  columns: &[
    ColumnDef::new("OBJNAM", "objnam", ColType::Text),
    // ...only required attributes...
  ],
  style_fn: Some(achare_style),
  style_layers: &[StyleLayerDef::new("fill", StyleLayerType::Fill)],
};
```

### 2. Implement Style Function (if needed)

- If custom styling is needed, implement a function (e.g., `fn achare_style(attrs: &Map<String, Value>) -> StyleProps`) in the same file, matching Njord's style logic.

### 3. Register the Feature

- In `src/features/mod.rs`:
  - Add `mod achare;` at the top.
  - Add `pub use achare::ACHARE;`.
  - Add `&ACHARE` to the array returned by `all_layers()` in the correct order (matching Njord's rendering order).

### 4. No SQL Migration Needed

- Table and indexes are auto-created at startup. To add columns to an existing layer, use a manual migration.

### 5. Test and Validate

- Run the pipeline and check that the new layer is imported, styled, and served as expected.

**Notes:**
- All feature layers are defined in their own file in `src/features/`.
- All layers must be registered in `mod.rs` and included in `all_layers()`.
- Style functions and style layers are per-feature and live in the same file, and should match Njord's conventions for area-based layers.

---

During import, each feature is assigned style tokens (`ac`, `lc`, `sy`) based on S-57 attributes. These flow into MVT tiles as properties `AC`, `LC`, and `SY`, which MapLibre/Mapbox GL can reference in style expressions.

### Generating a style JSON

Use `--style-output` to generate a Mapbox GL Style JSON without needing a database:

```bash
cargo run -- --style-output day.json --theme day --tile-source-url "http://localhost:3000"
```

Options:
- `--style-output <path>` — write the style JSON and exit
- `--sprites-output <dir>` — generate themed sprite SVGs and exit
- `--theme <day|dusk|night>` — color theme (default: `day`)
- `--tile-source-url <url>` — vector tile source URL embedded in the style (default: `http://localhost:3000`)

### Serving styles via Martin

Style files placed in the `styles/` directory are automatically served by Martin. Generate all assets with:

```bash
# Generate themed sprites
cargo run -- --sprites-output sprites/themed

# Generate style JSONs (includes sprite and glyphs URLs)
mkdir -p styles
for t in day dusk night; do
  cargo run -- --style-output styles/$t.json --theme $t
done
```

or ```./setup.sh```

After generating the files, restart Martin. Styles are available at:
- `http://localhost:3000/style/day`
- `http://localhost:3000/style/dusk`
- `http://localhost:3000/style/night`

**Martin configuration**: Ensure `martin.yaml` has the correct relative path:

```yaml
styles:
  paths:
    - ./styles
```

### Using the style

Load the generated JSON as a MapLibre GL style:

```js
const map = new maplibregl.Map({
  container: "map",
  style: "day.json", // or fetch and pass the object directly
});
```

### Adding styling to a new layer

When defining a `LayerDef`, add a `style_fn` and `style_layers`:

```rust
fn lights_style(attrs: &Map<String, Value>) -> StyleProps {
    StyleProps {
        ac: None,
        lc: None,
        sy: Some("LIGHTS01".into()),
    }
}

pub const LIGHTS: LayerDef = LayerDef {
    s57_name: "LIGHTS",
    table: "lights",
    columns: &[/* ... */],
    style_fn: Some(lights_style),
    style_layers: &[
        StyleLayerDef {
            id_suffix: "symbol",
            layer_type: StyleLayerType::Symbol,
            colors: &[],
            line_width: None,
        },
    ],
};
```

- `style_fn` — inspects S-57 attributes at import time and returns style tokens stored in the database
- `style_layers` — declares Mapbox GL style layers generated by `--style-output`
  - **Fill** layers use `AC` (area color) with a case expression mapping tokens to hex colors
  - **Line** layers use `LC` (line color) with an optional `line_width`
  - **Symbol** layers use `SY` (symbol name) as the `icon-image`

Color tokens (e.g. `DEPVS`, `LANDA`, `CSTLN`) are resolved to hex values from the selected theme. Colors are loaded from `colors.json` (S-52 color library with 64 tokens per theme).

## Sprites

Source SVG chart symbols (S-52 presentation library) live in `sprites/svg/`. These contain CSS class references (`fTOKEN` for fill, `sTOKEN` for stroke) that reference color tokens from `colors.json`.

### Generating themed sprites

Use `--sprites-output` to generate themed SVG directories with CSS inlined per theme:

```bash
cargo run -- --sprites-output sprites/themed
```

This creates `sprites/themed/{day,dusk,night}/` directories, each containing all SVGs with theme-appropriate colors inlined. These directories are gitignored — only the source SVGs in `sprites/svg/` are committed.

### Serving sprites via Martin

Martin auto-generates PNG sprite sheets from the themed SVG directories. After generating sprites and restarting Martin:

- `http://localhost:3000/sprite/day.json` — sprite manifest
- `http://localhost:3000/sprite/day.png` — sprite sheet
- `http://localhost:3000/sprite/day@2x.json` / `.png` — retina variants

The generated style JSONs automatically include the correct `sprite` URL for the selected theme.

### Configuration

Sprite paths in `martin.yaml` are relative to Martin's working directory. Because the docker-compose mounts `sprites/themed` as `/sprites` in the Martin container, the paths should be:

```yaml
sprites:
  sources:
    day: ./sprites/day
    dusk: ./sprites/dusk
    night: ./sprites/night
```

After updating paths, restart Martin for changes to take effect:
```bash
# From host machine (outside dev container)
docker compose -f .devcontainer/docker-compose.yml restart martin
```

## Fonts

Roboto TTF files in the `fonts/` directory are served by Martin as PBF glyph ranges for text rendering in MapLibre GL.

### Font Endpoints

Martin serves font glyphs at the following endpoints:

- `http://localhost:3000/font/Roboto Bold/0-255` — glyph range for Roboto Bold
- `http://localhost:3000/font/Roboto Regular/0-255` — glyph range for Roboto Regular
- `http://localhost:3000/font/Roboto Medium/0-255` — glyph range for Roboto Medium
- `http://localhost:3000/font/Roboto Italic/0-255` — glyph range for Roboto Italic

The generated style JSONs automatically include the `glyphs` URL template: `http://localhost:3000/font/{fontstack}/{range}`.

**Note**: When testing from inside the dev container, use `http://martin:3000` instead of `localhost:3000` to access Martin via Docker networking:
```bash
# Inside dev container
curl -I http://martin:3000/font/Roboto%20Bold/0-255
```

### Font Usage

Currently, text rendering is only used for **soundings (depth labels)**. Fonts will only be requested by the browser when:

1. You zoom to a level where soundings are visible (typically z12+)
2. The map viewport contains areas with sounding features
3. The text is within the current view

**Note**: If Martin shows 0 font requests, this is normal when:
- Viewing zoom levels without soundings (z0-z11)
- Viewing areas without depth measurements
- No soundings are present in the loaded ENC data

To test font serving, zoom to a detailed area (z14+) with soundings and verify text labels appear on depth points.

### Configuration

Font paths in `martin.yaml` use absolute paths matching the Docker volume mounts:

```yaml
fonts:
  - /fonts  # Absolute path in Martin container
```

## Zoom-Level Filtering (ZFinder)

MVT tile functions use njord-style ZFinder zoom filtering to control feature visibility. Instead of comparing raw scale denominators, chart and feature scales are converted to zoom levels inline:

```sql
zoom = 28 - CEIL(LN(scale) / LN(2))
```

A feature is included in a tile when both:
- The chart's `compilation_scale` zoom level is `<= z` (the requested tile zoom)
- The feature's `scamin` zoom level (if set) is `<= z`

| compilation_scale | Min visible zoom |
|-------------------|-----------------|
| 1,000,000         | 8               |
| 500,000           | 9               |
| 200,000           | 10              |
| 100,000           | 11              |
| 50,000            | 12              |
| 25,000            | 13              |
| 10,000            | 14              |

Where multiple charts overlap, features are ordered by `compilation_scale DESC` so more-detailed data renders on top of less-detailed data.

## Soundings (Depth Display)

Soundings are depth measurements extracted from S-57 SOUNDG features. The system automatically extracts depth values from point geometry Z-coordinates using GDAL's `ADD_SOUNDG_DEPTH=ON` option.

### Depth Unit Conversions

During MVT tile generation, depth values are automatically converted to multiple units and formats:

| Property | Description | Formula |
|----------|-------------|---------|
| `depth` | Original depth in meters (decimal) | From Z-coordinate |
| `depth_meters_whole` | Whole meters (integer) | `FLOOR(depth)` |
| `depth_meters_tenths` | Tenths digit (0-9) | `FLOOR((depth - FLOOR(depth)) * 10)` |
| `depth_feet` | Depth in feet (integer) | `ROUND(depth * 3.28084)` |
| `depth_fathoms` | Whole fathoms (integer) | `FLOOR(depth / 1.8288)` |
| `depth_fathoms_feet` | Fractional feet (0-5) | `ROUND((depth / 1.8288 - FLOOR(depth / 1.8288)) * 6)` |

**Conversion factors:**
- 1 meter = 3.28084 feet
- 1 fathom = 1.8288 meters = 6 feet

### Changing Depth Units

To display soundings in different units, modify the `text-field` property in the style JSON:

```json
{
  "id": "soundg_text",
  "type": "symbol",
  "source-layer": "soundg",
  "layout": {
    "text-field": ["to-string", ["get", "depth_feet"]],  // Change to depth_feet or depth_fathoms
    "text-font": ["Roboto Bold"],
    "text-size": 16.0
  }
}
```

Available `text-field` options:
- `depth_meters_whole` — Default: whole meters (e.g., "5")
- `depth_feet` — Imperial feet (e.g., "16")
- `depth_fathoms` — Nautical fathoms (e.g., "2")

### Depth-Conditional Styling

Soundings use depth-based color coding following S-52 presentation library conventions:

- **Shallow depths (<9m)**: SNDG2 token (black `#000000` in day theme)
- **Deep depths (≥9m)**: SNDG1 token (gray `#768C97` in day theme)

The 9-meter threshold distinguishes navigationally critical shallow areas from deeper safe water. Color values vary by theme (day/dusk/night) but maintain consistent semantic meaning.

### Advanced: Split Decimal Rendering

For professional nautical chart appearance with separate whole/decimal positioning (e.g., "5²" where ² is subscript tenths), you can create multiple text layers:

```json
[
  {
    "id": "soundg_whole",
    "layout": {
      "text-field": ["to-string", ["get", "depth_meters_whole"]],
      "text-anchor": "bottom-right",
      "text-size": 16.0
    }
  },
  {
    "id": "soundg_tenths",
    "layout": {
      "text-field": ["to-string", ["get", "depth_meters_tenths"]],
      "text-anchor": "top-left",
      "text-size": 12.0
    }
  }
]
```

## Performance Optimizations

The system includes several performance optimizations designed for high-throughput tile serving and efficient data ingestion at scale.

### Pre-computed Geometry and Zoom Levels

To eliminate expensive runtime calculations during tile generation, the system pre-computes and stores:

- **`geom_3857`**: Web Mercator (EPSG:3857) projection of geometries, stored alongside the original EPSG:4326 geometry
- **`min_zoom`**: Minimum zoom level calculated from the chart's `compilation_scale`
- **`max_zoom`**: Maximum zoom level calculated from the feature's `scamin` (scale minimum)

This optimization eliminates two major per-tile bottlenecks:
1. **Coordinate transformations**: No runtime `ST_Transform(geom, 3857)` calls
2. **Logarithmic calculations**: Zoom comparisons use simple integer lookups instead of `28 - CEIL(LN(scale) / LN(2))`

**Performance impact**: 40-60% reduction in tile generation latency.

### Tile Caching

Martin tile server is configured with file-based caching to dramatically reduce database load:

- **Cache directory**: `./tile_cache`
- **TTL**: 24 hours (86400 seconds)
- **Max size**: 10GB

Popular tiles are served from cache instead of regenerating from the database on every request.

**Performance impact**: 80-95% cache hit rate typical for production workloads, reducing database query volume proportionally.

### Parallel ENC Processing

ENC ingestion is parallelized to utilize multiple CPU cores. The system processes multiple ENC directories concurrently using tokio's thread pool with configurable concurrency limits.

**Configuration options:**
```bash
# Process 10 ENCs in parallel (default)
cargo run -- --input-dir ./ENCS --parallel-enc 10

# Adjust based on available CPU cores and database connections
cargo run -- --input-dir ./ENCS --parallel-enc 16
```

**Performance impact**: 5-10x speedup on multi-core systems compared to sequential processing.

### Connection Pool Tuning

Database connection pooling is configurable to balance resource utilization:

```bash
# Defaults: 20 max connections, 5 min connections
cargo run -- --input-dir ./ENCS

# Customize for high-traffic scenarios
cargo run -- --input-dir ./ENCS --max-connections 50 --min-connections 10

# Limit for resource-constrained environments
cargo run -- --input-dir ./ENCS --max-connections 10 --min-connections 2
```

**Recommended settings:**
- **Development**: 10 max / 2 min
- **Production (tile serving)**: 20-50 max / 5-10 min
- **Bulk ingestion**: Match or exceed `--parallel-enc` value

**Note**: Ensure PostgreSQL `max_connections` setting accommodates your pool size plus Martin tile server connections.

### Skip Already-Imported ENCs

The system tracks imported ENCs by edition and update number, skipping redundant processing:

```bash
# Normal mode: skips ENCs already in catalog with matching edition/update
cargo run -- --input-dir ./ENCS

# Force reimport even if already present
cargo run -- --input-dir ./ENCS --force-reimport
```

This makes imports idempotent and safe to re-run after failures or when adding new ENCs to an existing directory.

### PostgreSQL Tuning Recommendations

For optimal performance at scale, tune these PostgreSQL configuration parameters:

```ini
# Connection settings
max_connections = 100  # Accommodate pool + Martin

# Memory settings (adjust for available RAM)
shared_buffers = 4GB
effective_cache_size = 12GB
work_mem = 128MB
maintenance_work_mem = 1GB

# Query planner
random_page_cost = 1.1  # For SSD storage
effective_io_concurrency = 200

# Parallel query (for MVT functions)
max_parallel_workers_per_gather = 4
max_parallel_workers = 8
```

### Performance Metrics

**Expected improvements (vs. non-optimized baseline):**

| Metric | Before | After | Improvement |
|--------|--------|-------|-------------|
| Tile generation latency (p50) | 50-200ms | 20-80ms | 40-60% faster |
| Tile generation latency (cached) | N/A | <5ms | 10-40x faster |
| ENC ingestion throughput | 1 ENC/min | 5-10 ENCs/min | 5-10x faster |
| Database query load | 100% | 5-20% | 80-95% reduction |

**Scaling characteristics:**
- **Storage cost**: ~2x increase due to dual geometry columns (geom + geom_3857)
- **CPU utilization**: 70-90% during parallel ingestion (vs. 10-20% sequential)
- **Cache effectiveness**: Increases with geographic locality and zoom level popularity

### Migration Notes

These optimizations introduce schema changes (new columns and indexes). When upgrading from an earlier version:

1. **Fresh database**: Simply run the application; tables will be created with the optimized schema
2. **Existing data**: Either drop and recreate tables, or add columns/indexes manually:
   ```sql
   ALTER TABLE {table} ADD COLUMN geom_3857 GEOMETRY(GEOMETRY, 3857);
   ALTER TABLE {table} ADD COLUMN min_zoom SMALLINT;
   ALTER TABLE {table} ADD COLUMN max_zoom SMALLINT;
   
   UPDATE {table} SET 
     geom_3857 = ST_Transform(geom, 3857),
     min_zoom = (28 - CEIL(LN(GREATEST(compilation_scale, 1)::double precision) / LN(2)))::smallint,
     max_zoom = CASE WHEN scamin IS NOT NULL 
       THEN (28 - CEIL(LN(GREATEST(scamin, 1)::double precision) / LN(2)))::smallint 
       ELSE NULL END;
   
   CREATE INDEX {table}_geom_3857_idx ON {table} USING GIST(geom_3857);
   CREATE INDEX {table}_min_zoom_idx ON {table}(min_zoom) WHERE min_zoom IS NOT NULL;
   CREATE INDEX {table}_max_zoom_idx ON {table}(max_zoom) WHERE max_zoom IS NOT NULL;
   ```

For large datasets, the simplest approach is to reimport using `--force-reimport`.

## Development

### Prerequisites

- Docker (devcontainer includes Rust, GDAL, and PostgreSQL/PostGIS)
- S-57 ENC files in a directory

### Running

```bash
# Inside the devcontainer
cargo run -- --input-dir ./ENCS/DE_ENCs/ENC_ROOT
```

### CLI Options Reference

```bash
# Data ingestion
--input-dir <PATH>          # Path to ENC directory (required unless generating styles/sprites)
--force-reimport            # Force reimport even if ENC already in catalog

# Style and sprite generation
--style-output <PATH>       # Generate Mapbox GL style JSON and exit
--sprites-output <PATH>     # Generate themed sprite SVGs and exit
--theme <THEME>             # Color theme: day, dusk, or night (default: day)
--tile-source-url <URL>     # Tile source URL in style JSON (default: http://localhost:3000)

# Performance tuning
--parallel-enc <N>          # Number of ENCs to process concurrently (default: 10)
--max-connections <N>       # Database pool max connections (default: 20)
--min-connections <N>       # Database pool min connections (default: 5)

# Logging
--log-level <LEVEL>         # Log level: trace, debug, info, warn, error (default: info)
```

**Examples:**

```bash
# Import ENCs with custom parallelism
cargo run -- --input-dir ./ENCS --parallel-enc 16

# Generate all three themed styles
for theme in day dusk night; do
  cargo run -- --style-output styles/$theme.json --theme $theme
done

# High-performance production ingestion
cargo run -- \
  --input-dir ./ENCS \
  --parallel-enc 20 \
  --max-connections 50 \
  --min-connections 10 \
  --log-level warn

# Development with detailed logging
cargo run -- --input-dir ./ENCS --parallel-enc 2 --log-level debug
```

### Environment

Set `DATABASE_URL` in `.env` or your environment:

```
DATABASE_URL=postgresql://user:pass@localhost:5432/openenc
```
