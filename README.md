# rust-openenc

S-57 Electronic Navigational Chart (ENC) ingestion pipeline. Reads S-57 files via GDAL, extracts feature layers, and upserts them into PostGIS with MVT tile serving support.

## Adding a New Feature Layer

Adding a new S-57 feature layer requires two steps — no SQL migrations needed.

### 1. Add the layer definition

In `src/features/mod.rs`, add a const `LayerDef`:

```rust
pub const LIGHTS: LayerDef = LayerDef {
    s57_name: "LIGHTS",           // S-57 layer name from the .000 file
    table: "lights",              // PostgreSQL table name (auto-created at startup)
    columns: &[
        ColumnDef::new("COLOUR", "colour", ColType::Int),
        ColumnDef::new("LITCHR", "litchr", ColType::Int),
        ColumnDef::new("SIGPER", "sigper", ColType::Float),
        ColumnDef::new("VALNMR", "valnmr", ColType::Float),
        ColumnDef::new("OBJNAM", "objnam", ColType::Text),
    ],
    style_fn: None,               // Optional: see "Styling" section below
    style_layers: &[],
};
```

Available column types:
- `ColType::Float` — `NUMERIC` in SQL, binds as `Option<f64>`
- `ColType::Int` — `INTEGER` in SQL, binds as `Option<i32>`
- `ColType::Text` — `TEXT` in SQL, binds as `Option<&str>`

### 2. Register it

Add a reference to your new layer in the `all_layers()` function in `src/features/mod.rs`:

```rust
pub fn all_layers() -> &'static [&'static LayerDef] {
    &[&DEPARE, &LNDARE, &LIGHTS]
}
```

That's it. At startup, `ensure_layer_tables()` automatically creates the table (with standard columns, indexes, and unique constraint), the 4 standard indexes, and the MVT tile-serving function — all using idempotent DDL (`CREATE TABLE IF NOT EXISTS`, `CREATE INDEX IF NOT EXISTS`, `CREATE OR REPLACE FUNCTION`).

**Limitations:**
- Adding a column to an existing `LayerDef` won't alter the table — use a manual `ALTER TABLE` migration for that.
- Only the 4 standard indexes (geom GIST, scamin, enc_name, compilation_scale) are auto-generated. Add layer-specific indexes via manual migrations.

## Styling

During import, each feature is assigned style tokens (`ac`, `lc`, `sy`) based on S-57 attributes. These flow into MVT tiles as properties `AC`, `LC`, and `SY`, which MapLibre/Mapbox GL can reference in style expressions.

### Generating a style JSON

Use `--style-output` to generate a Mapbox GL Style JSON without needing a database:

```bash
cargo run -- --style-output day.json --theme day --tile-source-url "http://localhost:3000"
```

Options:
- `--style-output <path>` — write the style JSON and exit
- `--sprites-output <dir>` — generate themed sprite SVGs and exit
- `--theme <day|dusk|night>` — color theme (default: `day`)
- `--tile-source-url <url>` — vector tile source URL embedded in the style (default: `http://localhost:3000`)

### Serving styles via Martin

Style files placed in the `styles/` directory are automatically served by Martin. Generate all assets with:

```bash
# Generate themed sprites
cargo run -- --sprites-output sprites/themed

# Generate style JSONs (includes sprite and glyphs URLs)
mkdir -p styles
for t in day dusk night; do
  cargo run -- --style-output styles/$t.json --theme $t
done
```

After restarting Martin, styles are available at `http://localhost:3000/style/day`, `/style/dusk`, and `/style/night`.

### Using the style

Load the generated JSON as a MapLibre GL style:

```js
const map = new maplibregl.Map({
  container: "map",
  style: "day.json", // or fetch and pass the object directly
});
```

### Adding styling to a new layer

When defining a `LayerDef`, add a `style_fn` and `style_layers`:

```rust
fn lights_style(attrs: &Map<String, Value>) -> StyleProps {
    StyleProps {
        ac: None,
        lc: None,
        sy: Some("LIGHTS01".into()),
    }
}

pub const LIGHTS: LayerDef = LayerDef {
    s57_name: "LIGHTS",
    table: "lights",
    columns: &[/* ... */],
    style_fn: Some(lights_style),
    style_layers: &[
        StyleLayerDef {
            id_suffix: "symbol",
            layer_type: StyleLayerType::Symbol,
            colors: &[],
            line_width: None,
        },
    ],
};
```

- `style_fn` — inspects S-57 attributes at import time and returns style tokens stored in the database
- `style_layers` — declares Mapbox GL style layers generated by `--style-output`
  - **Fill** layers use `AC` (area color) with a case expression mapping tokens to hex colors
  - **Line** layers use `LC` (line color) with an optional `line_width`
  - **Symbol** layers use `SY` (symbol name) as the `icon-image`

Color tokens (e.g. `DEPVS`, `LANDA`, `CSTLN`) are resolved to hex values from the selected theme. Colors are loaded from `colors.json` (S-52 color library with 64 tokens per theme).

## Sprites

Source SVG chart symbols (S-52 presentation library) live in `sprites/svg/`. These contain CSS class references (`fTOKEN` for fill, `sTOKEN` for stroke) that reference color tokens from `colors.json`.

### Generating themed sprites

Use `--sprites-output` to generate themed SVG directories with CSS inlined per theme:

```bash
cargo run -- --sprites-output sprites/themed
```

This creates `sprites/themed/{day,dusk,night}/` directories, each containing all SVGs with theme-appropriate colors inlined. These directories are gitignored — only the source SVGs in `sprites/svg/` are committed.

### Serving sprites via Martin

Martin auto-generates PNG sprite sheets from the themed SVG directories. After generating sprites and restarting Martin:

- `http://localhost:3000/sprite/day.json` — sprite manifest
- `http://localhost:3000/sprite/day.png` — sprite sheet
- `http://localhost:3000/sprite/day@2x.json` / `.png` — retina variants

The generated style JSONs automatically include the correct `sprite` URL for the selected theme.

## Fonts

Roboto TTF files in `fonts/` are served by Martin as PBF glyph ranges for text rendering in MapLibre GL.

- `http://localhost:3000/font/Roboto Regular/0-255` — glyph range

Available variants: Regular, Bold, Medium, Italic.

The generated style JSONs automatically include the `glyphs` URL template.

## Zoom-Level Filtering (ZFinder)

MVT tile functions use njord-style ZFinder zoom filtering to control feature visibility. Instead of comparing raw scale denominators, chart and feature scales are converted to zoom levels inline:

```sql
zoom = 28 - CEIL(LN(scale) / LN(2))
```

A feature is included in a tile when both:
- The chart's `compilation_scale` zoom level is `<= z` (the requested tile zoom)
- The feature's `scamin` zoom level (if set) is `<= z`

| compilation_scale | Min visible zoom |
|-------------------|-----------------|
| 1,000,000         | 8               |
| 500,000           | 9               |
| 200,000           | 10              |
| 100,000           | 11              |
| 50,000            | 12              |
| 25,000            | 13              |
| 10,000            | 14              |

Where multiple charts overlap, features are ordered by `compilation_scale DESC` so more-detailed data renders on top of less-detailed data.

## Development

### Prerequisites

- Docker (devcontainer includes Rust, GDAL, and PostgreSQL/PostGIS)
- S-57 ENC files in a directory

### Running

```bash
# Inside the devcontainer
cargo run -- --input-dir ./ENCS/DE_ENCs/ENC_ROOT
```

### Environment

Set `DATABASE_URL` in `.env` or your environment:

```
DATABASE_URL=postgresql://user:pass@localhost:5432/openenc
```
